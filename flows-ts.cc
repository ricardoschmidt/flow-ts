/*
 * DESCRIPTION:
 *  This program reads a ASC-II file containing flows records generated by
 *  yaf/yafscii. The flow information is divided in timeseries and the load
 *  in bytes is equally distributed throughout the flow. This software can be
 *  used for creating a timeline and reading a timeline in different timescales.
 *
 * INPUT:
 *  The input file must have seven columns separated by one blank space. All
 *  columns are mandatory and must follow the specific order:
 *    <tart_time> <end_time> <duration> <saddr> <daddr> <packets> <bytes>
 *
 * OUTPUT:
 *  See function printLine().
 *
 * Ricardo de O. Schmidt
 * November 2, 2011
 *
 * Design and Analysis of Communication Systems (DACS)
 * University of Twente (UT)
 * The Netherlands
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <unistd.h>

#include <map>
#include <string>
#include <cstring>
#include <iostream>
#include <fstream>
#include <math.h>

#define LINELEN 110 // line length

#define PRINT_LIMIT " " // fields limiter used for printing output

using namespace std;

/* struct to store information from command line arguments */
struct controls_t {
  char op_type;
  int ts;
} controls;

/* struct to store information about the file to be read */
struct file_t {
  char *path;
  ifstream f;
  ofstream o;
} flow_file, tl_file, print_file;

/* struct to store flow information that is read from the file */
struct line_t {
  char stime[16], ltime[16], dur[9], saddr[16], daddr[16], pkts[15], bytes[15];
  char smls_aux[15], emls_aux[15]; // auxiliar start and end milliseconds in string format
  long int smls, emls; // start and end milliseconds
  string buf;
} line;

/* struct with timeline controls */
struct tl_ctrl_t {
  int key_day;
  int current_day, current_hour, current_min, current_sec, current_ml;
  int end_hour;
  //int start_day, start_hour, start_min, start_sec, start_ml;
  //int end_day, end_hour, end_min, end_sec, end_ml;
  string key;
} tl_ctrl;

/* 
 * timeline map; the key is the timestamp in milliseconds
 *
 */
typedef map<long int, double> tl_t;
tl_t tl_pkts, tl_bytes;

/**
 * char* getHourStr(char t[16])
 *
 * This function returns the hours from time in string format HH:MM:SS.LLL
 *
 */
char* getHourStr(char t[16]) {
  char *token;
  token = (char*)malloc(sizeof(char)*3);
  strncpy(token, t, 2);
  token[2] = '\0';
  return token;
}

/**
 * char* getMinStr(char t[16])
 *
 * This function returns the minutes from time in string format HH:MM:SS.LLL
 *
 */
char* getMinStr(char t[16]) {
  char *token, *aux;
  token = (char*)malloc(sizeof(char)*3);
  strncpy(token, strchr(t,':')+1, 2);
  token[2] = '\0';
  return token;
}

/**
 * char* getSecStr(char t[16])
 *
 * This function returns the seconds from time in string format HH:MM:SS.LLL
 *
 */
char* getSecStr(char t[16]) {
  char *token, *aux;
  token = (char*)malloc(sizeof(char)*3);
  strncpy(token, strrchr(t,':')+1, 2);
  token[2] = '\0';
  return token;
}

/**
 * char* getMSecStr(char t[16])
 *
 * This function returns the milliseconds from time in string format HH:MM:SS.LLL
 *
 */
char* getMSecStr(char t[16]) {
  char *token, *aux;
  token = (char*)malloc(sizeof(char)*4);
  strncpy(token, strchr(t,'.')+1, 4);
  token[6] = '\0';
  return token;
}

/**
 * char* getDay(long int t)
 *
 * This function returns the day from a timestamp
 *
 */
char* getDay(long int t) {
  string aux(ctime(&t));
  size_t len;
  char *token;

  token = (char*)malloc(sizeof(char)*3);

  /* erase week day and month */
  aux.erase(0, aux.find(" ")+1);
  aux.erase(0, aux.find(" ")+1);
  len = aux.copy(token, aux.find(" "), 0);

  return token;
}

/**
 * char* getHour()
 *
 * This function returns the hour from a timestamp
 *
 */
char* getHour(long int t) {
  char *token, *time;

  token = (char*)malloc(sizeof(char)*3);
  time = ctime(&t);
  strncpy(token, strchr(time,':')-2, 2);
  token[2] = '\0';

  return token;
}

/**
 * char* getMin()
 *
 * This function returns the minute from a timestamp
 *
 */
char* getMin(long int t) {
  char *token, *time;

  token = (char*)malloc(sizeof(char)*3);
  time = ctime(&t);
  strncpy(token, strchr(time,':')+1, 2);
  token[2] = '\0';

  return token;
}

/**
 * char* getSec()
 *
 * This function returns the second from a timestamp
 *
 */
char* getSec(long int t) {
  char *token, *time;

  token = (char*)malloc(sizeof(char)*3);
  time = ctime(&t);
  strncpy(token, strrchr(time,':')+1, 2);
  token[2] = '\0';

  return token;
}


/**
 * void printLine()
 *
 * This function prints a single line as output, inserting the field limiter and
 * also parsing the date from milliseconds to human readable format HH:MM:SS.LLL
 *
 * Output format:
 *  1 2        3            4        5   6    7
 *  # millisec hh:mm:ss.mmm hh:mm:ss mmm MBps Mbps
 *
 */
void printLine(int line_num, long int time_ml, double acc_bytes) {
  string pstr = "";
  long int secs;
  int msecs;
  int phour, pmin, psec;
  double mbytes, mbits;
  char buf[100];

  /* separate seconds and milliseconds */
  secs = (long int) time_ml/1000;
  msecs = (int) time_ml - secs*1000;

  phour = atoi(getHour(secs));
  pmin = atoi(getMin(secs));
  psec = atoi(getSec(secs));

  if (acc_bytes == 0) {
    mbytes = mbits = 0;
  }
  else {
    /* transform bytes to MB and Mb */
    mbytes = (double) acc_bytes/1000000;
    mbits = (double) mbytes * 8;
    /* transforms to MBps and Mbps */
    mbytes = mbytes/((double)controls.ts/1000);
    mbits = mbits/((double)controls.ts/1000);
  }

  /* TODO - option for printing in file */
  //fprintf(stdout, "%d%s%ld%s%02d:%02d:%02d.%03d%s%02d:%02d:%02d%s%03d%s%.2lf%s%.2lf\n",
  sprintf(buf, "%d%s%ld%s%02d:%02d:%02d.%03d%s%02d:%02d:%02d%s%03d%s%.2lf%s%.2lf\n",
      line_num, PRINT_LIMIT,
      time_ml, PRINT_LIMIT,
      phour, pmin, psec, msecs, PRINT_LIMIT,
      phour, pmin, psec, PRINT_LIMIT,
      msecs, PRINT_LIMIT,
      mbytes, PRINT_LIMIT,
      mbits);
  buf[sizeof(buf)] = '\0';
  print_file.o << buf;

  return;
}

/**
 * int procLine()
 *
 * This function separates all fields of the line that is read from the input
 * file. All values are stored in a struct line_t.
 *
 */
int procLine() {
  string aux;
  size_t pos, len;

  aux = line.buf;

  /* start time */
  len = aux.copy(line.stime, aux.find(" "), 0);
  line.stime[len] = '\0';
  aux.erase(0, aux.find(" ")+1);

  /* start milliseconds */
  len = aux.copy(line.smls_aux, aux.find(" "), 0);
  line.smls_aux[len] = '\0';
  aux.erase(0, aux.find(" ")+1);
  line.smls = atol(line.smls_aux);

  /* end time */
  len = aux.copy(line.ltime, aux.find(" "), 0);
  line.ltime[len] = '\0';
  aux.erase(0, aux.find(" ")+1);

  /* end milliseconds */
  len = aux.copy(line.emls_aux, aux.find(" "), 0);
  line.emls_aux[len] = '\0';
  aux.erase(0, aux.find(" ")+1);
  line.emls = atol(line.emls_aux);

  /* duration */
  len = aux.copy(line.dur, aux.find(" "), 0);
  line.dur[len] = '\0';
  aux.erase(0, aux.find(" ")+1);

  /* source address */
  len = aux.copy(line.saddr, aux.find(" "), 0);
  line.saddr[len] = '\0';
  aux.erase(0, aux.find(" ")+1);

  /* destination address */
  len = aux.copy(line.daddr, aux.find(" "), 0);
  line.daddr[len] = '\0';
  aux.erase(0, aux.find(" ")+1);

  /* number of packets */
  len = aux.copy(line.pkts, aux.find(" "), 0);
  line.pkts[len] = '\0';
  aux.erase(0, aux.find(" ")+1);

  /* number of bytes */
  len = aux.copy(line.bytes, aux.length(), 0);
  line.bytes[len] ='\0';

  return 0;
}

/**
 * int addToTimeline()
 *
 * This function adds the flow values from struct line_t to the timeline.
 *
 */
int addToTimeline() {
  int flow_bytes; // flow total bytes
  long int flow_dur; // flow duration in milliseconds
  long int cur_ml; // current millisecond, used to control the loop for updating the timeline
  double bytes_ml; // bytes per millisecond

  /* iterator to navigate through the timeline map */
  tl_t::iterator tl_it;

  /* flow total duration in milliseconds and total bytes */
  flow_dur = (long int) (atof(line.dur) * 1000);
  flow_bytes = atoi(line.bytes);

  /* if duration is equal to 0 milliseconds, the key is the start millisecond */
  if (flow_dur == 0) {
    tl_it = tl_bytes.find(line.smls);
    if (tl_it == tl_bytes.end()) { // create new entry
      tl_bytes.insert(pair<long int, double>(line.smls, flow_bytes));
    }
    else { // update existing entry
      tl_bytes[line.smls] += flow_bytes;
    }
    return 0;
  }

  /* average bytes per millisecond */
  bytes_ml = (double) flow_bytes/flow_dur;

  /*
   * This loop goes for every millisecond of the flow to distribute uniformely
   * the bytes along the flow's duration.
   *
   * WARNING: The very last second is not included. For fixing it, simply add 1
   * millisecond to the flow duration (flow_dur) and change < for <= in the
   * while bellow.
   *
   */
  cur_ml = line.smls;
  while (cur_ml <= line.emls) {

    /* check whether there is an entry for this millisecond already */
    tl_it = tl_bytes.find(cur_ml);
    if (tl_it == tl_bytes.end()) { // create new entry
      tl_bytes.insert(pair<long int, double>(cur_ml, bytes_ml));
    }
    else { // update existing entry
      tl_bytes[cur_ml] += bytes_ml;
    }

    cur_ml++;
  }

  return 0;
}

/**
 * int printTimeline()
 *
 * This function is called to print the content of the timeline according to the
 * requested timescale as informed in the command line argument
 *
 */
int printTimeline() {
  long int first_ml; // first millisecond in the timeline
  long int end_ml; // last millisecond in the timeline
  long int tl_size; // number of entries in the timeline (used for performance)
  long int cur_ml; // used to control the loop for printing the timeline
  double bytes_ts; // accumulated bytes per timescale
  long int rest_ml; // missing milliseconds at the end of timeline that is less than the timescale
  int line_counter = 0; // line counter that is printed as line ID

  /* variables used to read and store the timeline */
  string lbuf; // for reading lines from timeline file
  char cbuf[50]; // buffer for copying
  long int read_ml; // milliseconds from line
  double read_bytes; // bytes from line
  size_t p;

  /* open timeline file as specified in tl_file and inserts into a timeline map */
  /* TODO - this is not the optimal way of doing it, but is the fast to code,
   * must be changed in near future. In addition, if a 1 millisecond timescale
   * is requested, the printing can be done just after reading the line from the
   * file, i.e. it is not needed to store the values in a timeline map*/
  tl_file.f.open(tl_file.path);
  if (!tl_file.f.is_open()) {
    fprintf(stderr, "Error: can't open file %s\n", tl_file.path);
    return 1;
  }

  /* timeline map for storing read values */
  tl_bytes.clear();

  /* loop to read line by line from timeline file */
  while(!tl_file.f.eof()) {
    /* get new line */
    lbuf.clear();
    getline(tl_file.f, lbuf);
    if (lbuf != "") {
      /* separate milliseconds and bytes */
      p = lbuf.find(" ");
      lbuf.copy(cbuf, p, 0);
      cbuf[sizeof(cbuf)] = '\0';
      read_ml = strtol(cbuf, NULL, 10);
      lbuf.copy(cbuf, lbuf.size()-p+1, p+1);
      read_bytes = (double) atof(cbuf);

      /* save into timeline map */
      tl_bytes[read_ml] = read_bytes;
    }
  }
  tl_file.f.close();

  /* open output file as specified in print_file */
  print_file.o.open(print_file.path);
  if (!print_file.o.is_open()) {
    fprintf(stderr, "Error: can't open file %s\n", print_file.path);
    return 1;
  }

  /* iterator to navigate through the timeline map */
  tl_t::iterator tl_it;

  /* timeline start time */
  tl_it = tl_bytes.begin();
  first_ml = (*tl_it).first;

  /* timeline end time */
  tl_it = tl_bytes.end();
  --tl_it;
  end_ml = (*tl_it).first;

  /* easy way for printing 1 millisecond timescale */
  if (controls.ts == 1) {
    for (tl_it = tl_bytes.begin(); tl_it != tl_bytes.end(); tl_it++) {
      printLine(++line_counter, (*tl_it).first, (*tl_it).second);
    }
    return 0;
  }

  /* loop for passing through all timeline entries */
  cur_ml = first_ml;
  while (cur_ml <= end_ml) {
    bytes_ts = 0;

    /* if the last millisecond are less than the timescale */
    if ((end_ml - cur_ml + 1) < controls.ts) {
      rest_ml = end_ml - cur_ml + 1;
      for (int i=0; i<rest_ml; i++) {
        tl_it = tl_bytes.find(cur_ml+i);
        bytes_ts += (*tl_it).second;
      }
      //bytes_ts = bytes_ts/rest_ml;
      //printLine(++line_counter, cur_ml, bytes_ts);
      cur_ml += controls.ts;
    }
    else {
      for (int i=0; i<controls.ts; i++) {
        tl_it = tl_bytes.find(cur_ml+i);
        bytes_ts += (*tl_it).second;
      }

      //bytes_ts = bytes_ts/controls.ts;
      printLine(++line_counter, cur_ml, bytes_ts);

      cur_ml += controls.ts;
    }

  }

  print_file.o.close();

  return 0;
}

/**
 * int fillTimeGaps()
 *
 * This function fills all time gaps in the timeline, considering a milliseconds
 * timescale.
 *
 *  TODO - this function can be joined with fillTimeGaps, so that only one loop
 *  will be executed through the timeline.
 *
 */
int fillTimeGaps() {
  long int prev_ml; // previous millisecond
  long int cur_ml; // current millisecond

  /* iterator to navigate through the timeline map */
  tl_t::iterator tl_it;

  /* control variables initialization */
  tl_it = tl_bytes.begin();
  cur_ml = (*tl_it).first;
  prev_ml = cur_ml - 1;

  /* loop for passing through all entries in the timeline map */
  for (tl_it = tl_bytes.begin(); tl_it != tl_bytes.end(); tl_it++) {
    cur_ml = (*tl_it).first;
    if (cur_ml - prev_ml != 1) {
      prev_ml++;
      while (prev_ml < cur_ml) {
        tl_bytes.insert(pair<long int, double>(prev_ml, 0));
        prev_ml++;
      }
    }
    prev_ml = cur_ml;
  }

  return 0;
}

/**
 *  int saveTL()
 *
 *  This function save/write the timeline to the file given in < tl_file.path >.
 *
 *  TODO - this function can be joined with fillTimeGaps, so that only one loop
 *  will be executed through the timeline.
 *
 */
int saveTL() {
  char buf[100];

  /* open output file */
  tl_file.o.open(tl_file.path);
  if (!tl_file.o.is_open()) {
    fprintf(stderr, "Error: can't open file %s\n", tl_file.path);
    return 1;
  }

  /* loop for passing through all entries in the timeline */
  for (tl_t::iterator tl_it = tl_bytes.begin(); tl_it != tl_bytes.end(); tl_it++) {
    sprintf(buf, "%ld %.6lf\n", (*tl_it).first, (*tl_it).second);
    buf[sizeof(buf)] = '\0';
    tl_file.o << buf;
  }

  tl_file.o.close();

  return 0;
}

/**
 * int tsSec()
 *
 * This function is called to process flows in a timescale of seconds.
 *
 */
int tsSec() {
  string bl;

  tl_pkts.clear();
  tl_bytes.clear();

  tl_ctrl.key_day = -1;
  tl_ctrl.end_hour = -1;

  flow_file.f.open(flow_file.path);
  if (!flow_file.f.is_open()) {
    fprintf(stderr, "Error: can't open file %s\n", flow_file.path);
    return 1;
  }

  /* loop to read line by line from flow file */
  while(!flow_file.f.eof()) {
    /* get new line */
    line.buf.clear();
    getline(flow_file.f, line.buf);
    if (line.buf != "") {
      procLine(); // split line info
      addToTimeline(); // add info to the timeline
    }
  }

  flow_file.f.close();

  /* still need a function for filling the time gaps with 0 bytes */
  if (fillTimeGaps() > 0) {
    fprintf(stderr, "Error in fillTimeGaps()\nExiting...\n");
    return 0;
  }

  /* save timeline to file specified as output in tl_file */
  if (saveTL() > 0) {
    fprintf(stderr, "Error in saveTL()\nExiting...\n");
    return 0;
  }

  return 0;
}

/**
 * int main(int argc, char **argv)
 *
 */
int main(int argc, char **argv) {
  /* check if all arguments were provided */
  if (argc < 2 ||
      (*argv[1] != 'c' && *argv[1] != 'p') ||
      (*argv[1] == 'c' && argc != 4) ||
      (*argv[1] == 'p' && argc != 5)) {
    fprintf(stdout, "Usage:\n - creating a timeline:\n");
    fprintf(stdout, "    # %s c <flow file> <output file>\n", argv[0]);
    fprintf(stdout, " - printing a timeline:\n");
    fprintf(stdout, "    # %s p <milliseconds timescale> <timeline file> <output file>\n", argv[0]);
    return 0;
  }

  /* copying arguments to struct variables */
  controls.op_type = *argv[1];
  if (controls.op_type == 'c') {
    flow_file.path = argv[2];
    tl_file.path = argv[3];
  }
  else if (controls.op_type == 'p') {
    controls.ts = atoi(argv[2]);
    tl_file.path = argv[3];
    print_file.path = argv[4];
  }

  if (controls.op_type == 'c') {
    /* create timeline from flow_file and save to tl_file */
    if (tsSec() > 0) {
      fprintf(stderr, "Error in tsSec()\nExisting...\n");
      return 0;
    }
  }
  else if (controls.op_type == 'p') { // print timeline
    /* print timeline according to the requested timescale */
    printTimeline();
  }
  else {
    fprintf(stderr, "Unknown operation type %c\nExisting...\n", controls.op_type);
    exit(0);
  }

  return 0;
}
